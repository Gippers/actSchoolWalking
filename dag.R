# Overall, this script is focused on using the ERP, school location and mainly 
# Author Claude 3.5 Sonnet & Thomas Martin

library(sf)
library(dplyr)
library(dodgr)
library(osmdata)
library(ggplot2)
library(geodist)

#--------------------------------------------------------
# Load sa2 data
#--------------------------------------------------------

erp <- st_read("data/erp_sa2.gpkg") # ERP data
schools_sf <- st_read("data/cleaned/school_locations.gpkg") # School locations


# TODO change later: For now only analyis 10-14 age group
erp <- erp |>
    filter(age %in% c("5-9", "10-14"))

# Generate random points within each SA2 polygon
generate_random_points <- function(erp_data, n_points = 10) {
  # Get unique SA2s with their geometries (use most recent year for geometry)
  sa2_polygons <- erp_data |>
    filter(year == 2024) |>  # Use 2024 geometry
    select(sa2_code, sa2_name, geom) |>
    distinct(sa2_code, .keep_all = TRUE)
  
  # Generate random points for each SA2
  random_points <- sa2_polygons |>
    rowwise() |>
    do({
      # Generate n_points random points within each polygon
      points <- st_sample(.$geom, size = n_points, type = "random")
      
      # Convert to sf data frame with SA2 information
      if (length(points) > 0) {
        data.frame(
          sa2_code = .$sa2_code,
          sa2_name = .$sa2_name,
          point_id = 1:length(points),
          geometry = points
        )
      } else {
        # Handle case where no points could be generated
        NULL
      }
    }) |>
    bind_rows() |>
    st_as_sf()
  
  return(random_points)
}

# Generate the random points
set.seed(1234)  # For reproducible results
random_locations <- generate_random_points(erp, n_points = 10)

# Add coordinates as columns for easier access
coords <- st_coordinates(random_locations)
random_locations$longitude <- coords[,1]
random_locations$latitude <- coords[,2]


# Check the results
cat("Generated", nrow(random_locations), "random points\n")
cat("Across", length(unique(random_locations$sa2_code)), "SA2 areas\n")

# Save for later ACT walking analysis
st_write(random_locations, "data/random_points_act.gpkg", delete_dsn = TRUE)

# Ensure WGS84 for OSM/dodgr
#braddon <- st_transform(braddon, 4326)



# ---- 1) Build ACT walk network (OSM via dodgr) ----
# Generated by Claude 3.5 Sonnet
# Function to build or load ACT walking network
build_act_network <- function(erp_data, 
                              year_selected = 2024,
                              load_existing = TRUE) {
  #' @description builds and save a walk network in the act. The purpose is
  #' to analyse the walk distance of school aged children to government high schools
  #' and primary schools.
  #' @param erp_data (sf): The erp spatial data
  #' @param year_selected (int): The year of the erp data
  #' @param load_existing (logical): If TRUE, loads existing network from file if available
  
  # Define file paths
  file_suffix <- paste0("_", year_selected)
  net_w_file <- paste0("data_large/act_walking_network", file_suffix, ".rds")
  net_contracted_file <- paste0("data_large/act_walking_network_contracted", file_suffix, ".rds")
  
  # Try to load existing networks if requested and files exist
  if (load_existing && file.exists(net_w_file) && file.exists(net_contracted_file)) {
    cat("Loading existing ACT walking network for", year_selected, "from local files\n")
    
    net_w <- readRDS(net_w_file)
    net_contracted <- readRDS(net_contracted_file)
    
    # Create ACT boundary for consistency
    canberra <- erp_data |>
      filter(year == year_selected) |>
      select(geom) |>
      st_union() |>
      st_as_sf()
    
    canberra <- st_transform(canberra, 4326)
    
    cat("Loaded network with", nrow(net_w), "edges (original) and", 
        nrow(net_contracted), "edges (contracted)\n")
    
    return(list(
      net_w = net_w,
      net_contracted = net_contracted,
      canberra_boundary = canberra
    ))
  }
  
  # If not loading existing or files don't exist, build new network
  cat("Building new ACT walking network for", year_selected, "\n")
  
  # Create ACT boundary from erp data for the selected year
  canberra <- erp_data |>
    filter(year == year_selected) |>
    select(geom) |>
    st_union() |>
    st_as_sf()
  
  # Ensure WGS84 for OSM/dodgr
  canberra <- st_transform(canberra, 4326)
  
  # Build ACT walking network (OSM via dodgr)
  bb <- st_bbox(st_buffer(canberra, 200))
  net_raw <- dodgr_streetnet(bb)
  net_w <- weight_streetnet(net_raw, wt_profile = "foot")
  
  # Contract the graph for performance
  cat("Original graph size:", nrow(net_w), "edges\n")
  net_contracted <- dodgr_contract_graph(net_w)
  cat("Contracted graph size:", nrow(net_contracted), "edges\n")
  cat("Size reduction:", round((1 - nrow(net_contracted)/nrow(net_w)) * 100, 1), "%\n")
  
  # Save networks with year suffix
  saveRDS(net_w, net_w_file)
  saveRDS(net_contracted, net_contracted_file)
  
  cat("ACT walking network for", year_selected, "saved successfully\n")
  
  # Return both networks and boundary
  return(list(
    net_w = net_w,
    net_contracted = net_contracted,
    canberra_boundary = canberra
  ))
}

# Now you can load existing network (default behavior)
act_networks_2024 <- build_act_network(erp, 2024)

# Or force rebuild if needed
# act_networks_2024 <- build_act_network(erp, 2024, load_existing = FALSE)

# Access the networks
net_w <- act_networks_2024$net_w
net_contracted <- act_networks_2024$net_contracted
canberra <- act_networks_2024$canberra_boundary

# ---- 2) Use ACT Walk Network To Cacluate Shortest Walk Distance to School ----
# Generated by Claude 3.5 Sonnet
# Refactored function to be more modular for ACT school analysis
analyze_school_walking_times <- function(year_selected, 
                                        erp_data,
                                        random_locations,
                                        schools_sf,
                                        act_networks,
                                        save_results = FALSE) {
  #' @description Calculate walk times to nearest schools for ACT analysis
  #' @param year_selected (int): The analysis year
  #' @param erp_data (sf): ERP population data with age groups
  #' @param random_locations (sf): Random points within each SA2
  #' @param schools_sf (sf): School location data
  #' @param act_networks (list): Walking network from build_act_network()
  #' @param save_results (logical): If TRUE, saves results to file
  
  library(sf)
  library(dplyr)
  library(dodgr)
  
  cat("Analyzing walking times for ACT schools in", year_selected, "\n")
  
  # Filter schools that were open in the selected year
  schools_active <- schools_sf |>
    filter(open <= year_selected & (is.na(close) | close >= year_selected))
  
  cat("Active schools in", year_selected, ":", nrow(schools_active), "\n")
  
  # Get population data for the selected year
  pop_data <- erp_data |>
    filter(year == year_selected) |>
    select(sa2_code, age, erp)
  
  # Split schools by type for separate analysis
  primary_schools <- schools_active |> filter(type == "primary")
  high_schools <- schools_active |> filter(type == "high")
  
  # Use contracted network for faster computation
  network <- act_networks$net_contracted
  
  # Function to calculate walking times to nearest school of each type
  calculate_walking_times <- function(points, schools, school_type) {
    if (nrow(schools) == 0) {
      return(data.frame(
        sa2_code = points$sa2_code,
        point_id = points$point_id,
        school_type = school_type,
        nearest_walk_time_min = NA,
        nearest_school = NA
      ))
    }
    
    # Extract coordinates
    point_coords <- st_coordinates(points)
    school_coords <- st_coordinates(schools)
    
    # Calculate walking times using dodgr (returns seconds)
    walking_times_sec <- dodgr_times(
      network,
      from = point_coords,
      to = school_coords
    )
    
    # Convert to minutes
    walking_times_min <- walking_times_sec / 60
    
    # Find nearest school for each point (shortest time)
    nearest_idx <- apply(walking_times_min, 1, function(x) {
      if (all(is.na(x))) return(NA)
      which.min(x)
    })
    
    nearest_times <- sapply(1:nrow(walking_times_min), function(i) {
      if (is.na(nearest_idx[i])) return(NA)
      walking_times_min[i, nearest_idx[i]]
    })
    
    nearest_schools <- ifelse(is.na(nearest_idx), NA, schools$school[nearest_idx])
    
    return(data.frame(
      sa2_code = points$sa2_code,
      point_id = points$point_id,
      school_type = school_type,
      nearest_walk_time_min = nearest_times,
      nearest_school = nearest_schools
    ))
  }
  
  # Calculate walking times to nearest primary and high schools
  cat("Calculating walking times to primary schools...\n")
  primary_times <- calculate_walking_times(random_locations, primary_schools, "primary")
  
  cat("Calculating walking times to high schools...\n")
  high_times <- calculate_walking_times(random_locations, high_schools, "high")
  
  # Combine results - this is the key output for optimal location function
  all_times <- bind_rows(primary_times, high_times)
  
  # Calculate SA2-level summary statistics (in minutes)
  sa2_summary <- all_times |>
    group_by(sa2_code, school_type) |>
    summarise(
      mean_walk_time_min = mean(nearest_walk_time_min, na.rm = TRUE),
      median_walk_time_min = median(nearest_walk_time_min, na.rm = TRUE),
      min_walk_time_min = min(nearest_walk_time_min, na.rm = TRUE),
      max_walk_time_min = max(nearest_walk_time_min, na.rm = TRUE),
      n_points = sum(!is.na(nearest_walk_time_min)),
      .groups = "drop"
    ) |>
    # Add population weights
    left_join(
      pop_data |>
        mutate(
          weight_age = case_when(
            age == "5-9" ~ "primary",
            age == "10-14" ~ "high",
            TRUE ~ NA_character_
          )
        ) |>
        filter(!is.na(weight_age)) |>
        select(sa2_code, weight_age, population = erp),
      by = c("sa2_code", "school_type" = "weight_age")
    ) |>
    # Calculate weighted metrics
    mutate(
      weighted_mean_walk_time = mean_walk_time_min * population,
      year = year_selected
    )
  
  # Only add geometry and save if requested
  if (save_results) {
    # Add geometry and sa2_name
    sa2_info <- erp_data |>
      filter(year == year_selected) |>
      select(sa2_code, sa2_name, geom) |>
      distinct(sa2_code, .keep_all = TRUE) |>
      st_drop_geometry()
    
    sa2_geom <- erp_data |>
      filter(year == year_selected) |>
      select(sa2_code, geom) |>
      distinct(sa2_code, .keep_all = TRUE)
    
    final_results <- sa2_summary |>
      left_join(sa2_info, by = "sa2_code") |>
      left_join(sa2_geom, by = "sa2_code") |>
      st_as_sf()
    
    # Create output directory
    if (!dir.exists("data/walk_analysis")) {
      dir.create("data/walk_analysis", recursive = TRUE)
    }
    
    # Save results
    output_file <- paste0("data/walk_analysis/school_walk_times_", year_selected, ".gpkg")
    st_write(final_results, output_file, delete_dsn = TRUE)
    
    cat("Saved results to:", output_file, "\n")
  }
  
  cat("Summary - SA2s with valid walking times:\n")
  if (save_results && exists("final_results")) {
    print(table(final_results$school_type))
    cat("Average walking times by school type:\n")
    print(aggregate(mean_walk_time_min ~ school_type, final_results, mean, na.rm = TRUE))
    
    return(list(
      point_level = all_times,
      sa2_summary = sa2_summary,
      sa2_with_geometry = final_results
    ))
  } else {
    return(list(
      point_level = all_times,
      sa2_summary = sa2_summary
    ))
  }
}

# Read in the schools data


# Run analysis for 2024 with walking times
walk_times_2024 <- analyze_school_walking_times(
  year_selected = 2024,
  erp_data = erp,
  random_locations = random_locations,
  schools_sf = schools_sf,
  act_networks = act_networks_2024,
  save_results = T
)

# Run analysis for 2001 with walking times
walk_times_2024 <- analyze_school_walking_times(
  year_selected = 2001,
  erp_data = erp,
  random_locations = random_locations,
  schools_sf = schools_sf,
  act_networks = act_networks_2024,
  save_results = T
)

#-------------------------------------------------------------------------------
# ---- 3) Best School Location to Minimise Walk Distance ----
#-------------------------------------------------------------------------------
# Generated by Claude 3.5 Sonnet
#' Find Optimal School Location to Minimize Walking Times in ACT
#'
#' @description Finds the optimal location for a new school that would result in
#'   the largest overall decrease in walking times for school-aged children in the
#'   Australian Capital Territory. Uses a grid-based optimization approach.
#'
#' @param year_selected integer. The analysis year for filtering active schools and population data
#' @param erp_data sf object. ERP population data with age groups and geometry
#' @param random_locations sf object. Random points within each SA2 for analysis
#' @param schools_sf sf object. School location data with opening/closing years
#' @param act_networks list. Walking network from build_act_network() function
#' @param school_type character. Either "primary" or "high" school type
#' @param grid_resolution integer. Number of candidate locations per dimension (default 10)
#' @param top_candidates integer. Number of best locations to return (default 3)
#' @param n_candidates integer. Total number of candidate locations to test (overrides grid_resolution if provided)
#'
#' @return sf object with optimal school locations, time savings, and average walking times
#' @export
# Generated by Claude 3.5 Sonnet
# Fixed function with proper vector length handling for ACT analysis
find_optimal_school_location <- function(year_selected,
                                       erp_data,
                                       random_locations,
                                       schools_sf,
                                       act_networks,
                                       school_type = "primary",
                                       grid_resolution = 10,
                                       top_candidates = 3,
                                       n_candidates = NULL) {
  
  library(sf)
  library(dplyr)
  library(dodgr)
  
  cat("Finding optimal", school_type, "school location for ACT in", year_selected, "\n")
  
  # Get baseline walking times
  baseline_results <- analyze_school_walking_times(
    year_selected = year_selected,
    erp_data = erp_data,
    random_locations = random_locations,
    schools_sf = schools_sf,
    act_networks = act_networks,
    save_results = FALSE
  )
  
  # Extract baseline times and add population weights
  baseline_times <- baseline_results$point_level |>
    filter(school_type == !!school_type)
  
  target_age <- if (school_type == "primary") "5-9" else "10-14"
  pop_weights <- erp_data |>
    filter(year == year_selected, age == target_age) |>
    select(sa2_code, population = erp)
  
  baseline_weighted <- baseline_times |>
    left_join(pop_weights, by = "sa2_code") |>
    filter(population > 0, !is.na(nearest_walk_time_min))
  
  # Calculate current average walking time across ACT
  current_avg_time <- weighted.mean(
    baseline_weighted$nearest_walk_time_min, 
    baseline_weighted$population,
    na.rm = TRUE
  )
  
  cat("Current average walking time to", school_type, "schools:", 
      round(current_avg_time, 1), "minutes\n")
  cat("Using", nrow(baseline_weighted), "points for optimization\n")
  
  # Create candidate grid across populated areas
  populated_points <- random_locations |>
    inner_join(st_drop_geometry(pop_weights), by = "sa2_code") |>
    filter(population > 0)
  
  # IMPORTANT: Align populated_points with baseline_weighted
  # Ensure they have the same points in the same order
  baseline_weighted <- baseline_weighted |>
    arrange(sa2_code, point_id)
  
  populated_points <- populated_points |>
    semi_join(baseline_weighted, by = c("sa2_code", "point_id")) |>
    arrange(sa2_code, point_id)
  
  cat("Aligned", nrow(baseline_weighted), "points with", nrow(populated_points), "locations\n")
  
  # Simple grid over the bounding box of populated areas
  bbox <- st_bbox(populated_points)
  
  # Use n_candidates if provided, otherwise use grid_resolution
  if (!is.null(n_candidates)) {
    grid_size <- ceiling(sqrt(n_candidates))
    lon_seq <- seq(bbox["xmin"], bbox["xmax"], length.out = grid_size)
    lat_seq <- seq(bbox["ymin"], bbox["ymax"], length.out = grid_size)
    candidate_coords <- expand.grid(lon = lon_seq, lat = lat_seq)[1:n_candidates, ]
  } else {
    lon_seq <- seq(bbox["xmin"], bbox["xmax"], length.out = grid_resolution)
    lat_seq <- seq(bbox["ymin"], bbox["ymax"], length.out = grid_resolution)
    candidate_coords <- expand.grid(lon = lon_seq, lat = lat_seq)
  }
  
  cat("Testing", nrow(candidate_coords), "candidate locations\n")
  
  # Calculate improvement for each candidate
  improvements <- sapply(1:nrow(candidate_coords), function(i) {
    if (i %% 25 == 0) cat("Processed", i, "of", nrow(candidate_coords), "candidates\n")
    
    tryCatch({
      # Calculate time savings if new school was at this location
      new_coords <- as.numeric(candidate_coords[i, ])
      
      # Create properly formatted matrix for dodgr
      new_coords_matrix <- matrix(new_coords, nrow = 1, ncol = 2)
      colnames(new_coords_matrix) <- c("x", "y")
      
      # Calculate distances from all points to this new location
      point_coords <- st_coordinates(populated_points)
      
      # Calculate times to new school location
      new_times <- dodgr_times(
        act_networks$net_contracted,
        from = point_coords,
        to = new_coords_matrix
      ) / 60  # Convert to minutes
      
      # Handle case where new_times might be different length
      if (length(new_times) != nrow(baseline_weighted)) {
        return(0)  # Return 0 improvement if lengths don't match
      }
      
      # For each point, take minimum of current time vs time to new school
      current_times <- baseline_weighted$nearest_walk_time_min
      improved_times <- pmin(current_times, as.numeric(new_times), na.rm = TRUE)
      
      # Calculate total improvement (reduction in walking time)
      improvements_per_point <- current_times - improved_times
      
      # Weight by population and sum
      total_improvement <- sum(improvements_per_point * baseline_weighted$population, na.rm = TRUE)
      
      return(total_improvement)
    }, error = function(e) {
      return(0)  # Return 0 improvement if error occurs
    })
  })
  
  # Calculate new average walking times for top candidates
  new_avg_times <- sapply(1:nrow(candidate_coords), function(i) {
    tryCatch({
      new_coords <- as.numeric(candidate_coords[i, ])
      new_coords_matrix <- matrix(new_coords, nrow = 1, ncol = 2)
      colnames(new_coords_matrix) <- c("x", "y")
      
      point_coords <- st_coordinates(populated_points)
      new_times <- dodgr_times(
        act_networks$net_contracted,
        from = point_coords,
        to = new_coords_matrix
      ) / 60
      
      # Handle mismatched lengths
      if (length(new_times) != nrow(baseline_weighted)) {
        return(current_avg_time)  # Return current average if lengths don't match
      }
      
      current_times <- baseline_weighted$nearest_walk_time_min
      improved_times <- pmin(current_times, as.numeric(new_times), na.rm = TRUE)
      
      # Calculate new weighted average
      weighted.mean(improved_times, baseline_weighted$population, na.rm = TRUE)
    }, error = function(e) {
      return(current_avg_time)  # Return current average if error occurs
    })
  })
  
  # Get top candidates
  best_indices <- order(improvements, decreasing = TRUE)[1:top_candidates]
  
  results <- data.frame(
    longitude = candidate_coords$lon[best_indices],
    latitude = candidate_coords$lat[best_indices],
    total_time_saved_min = improvements[best_indices],
    new_avg_walk_time_min = new_avg_times[best_indices],
    current_avg_walk_time_min = current_avg_time,
    time_reduction_min = current_avg_time - new_avg_times[best_indices],
    rank = 1:top_candidates
  ) |>
    st_as_sf(coords = c("longitude", "latitude"), crs = 4326)
  
  # Add back coordinate columns for easier access
  coords_df <- st_coordinates(results)
  results$longitude <- coords_df[,1]
  results$latitude <- coords_df[,2]
  
  # Create output directory and save results
  if (!dir.exists("data/new_schools")) {
    dir.create("data/new_schools", recursive = TRUE)
  }
  
  output_file <- paste0("data/new_schools/optimal_", school_type, "_location_", year_selected, ".gpkg")
  st_write(results, output_file, delete_dsn = TRUE)
  
  cat("\nOptimal", school_type, "school locations for", year_selected, ":\n")
  cat("Best location saves", round(max(improvements), 0), "person-minutes per trip\n")
  cat("Reduces average walking time from", round(current_avg_time, 1), "to", 
      round(min(new_avg_times[best_indices]), 1), "minutes\n")
  cat("Results saved to:", output_file, "\n")
  
  return(results)
}

# Test with customizable candidate numbers
optimal_high_2024 <- find_optimal_school_location(
  year_selected = 2024,
  erp_data = erp,
  random_locations = random_locations,
  schools_sf = schools_sf,
  act_networks = act_networks_2024,
  school_type = "high",
  n_candidates = 100  # Test 50 specific locations
)

# Now run the complete analysis
optimal_primary_2024 <- find_optimal_school_location(
  year_selected = 2024,
  erp_data = erp,
  random_locations = random_locations,
  schools_sf = schools_sf,
  act_networks = act_networks_2024,
  school_type = "primary",
  n_candidates = 100  # Test 50 specific locations
)


#-------------------------------------------------------------------------------
# ---- 4) How many students have this as their closest school? ----
#-------------------------------------------------------------------------------

# Generated by Claude 3.5 Sonnet
#' Calculate School Catchments Based on Walking Distance in ACT
#'
#' @description Determines for each school how many children (by age group) have
#'   that school as their closest walking option. Flips the previous SA2 analysis
#'   to focus on individual schools and their catchment populations.
#'
#' @param year_selected integer. The analysis year for filtering active schools and population data
#' @param erp_data sf object. ERP population data with age groups and geometry
#' @param random_locations sf object. Random points within each SA2 for analysis
#' @param schools_sf sf object. School location data with opening/closing years
#' @param act_networks list. Walking network from build_act_network() function
#' @param save_results logical. If TRUE, saves results to closest_school folder
#'
#' @return sf object with school catchment data including population served and walking times
#' @export
# Generated by Claude 3.5 Sonnet
get_school_catchments <- function(year_selected, 
  erp_data, random_locations, schools_sf, act_networks) {
  
  # Get walking times
  walking_analysis <- analyze_school_walking_times(
    year_selected = year_selected,
    erp_data = erp_data,
    random_locations = random_locations,
    schools_sf = schools_sf,
    act_networks = act_networks,
    save_results = FALSE
  )
  
  # Get all active schools for this year
  active_schools <- schools_sf |>
    filter(open <= year_selected & (is.na(close) | close >= year_selected)) |>
    select(school, type) |>
    distinct() # Remove any duplicate school entries
  
  # Get population data
  pop_data <- erp_data |>
    filter(year == year_selected) |>
    select(sa2_code, age, population = erp)
  
  # Calculate children per point
  points_per_sa2 <- random_locations |>
    st_drop_geometry() |>
    count(sa2_code, name = "n_points")
  
  # Calculate catchments for schools with children
  results_with_children <- walking_analysis$point_level |>
    filter(!is.na(nearest_school)) |>
    left_join(
      pop_data |> filter(age %in% c("5-9", "10-14")),
      by = "sa2_code",
      relationship = "many-to-many"
    ) |>
    filter(
      (school_type == "primary" & age == "5-9") |
      (school_type == "high" & age == "10-14")
    ) |>
    left_join(points_per_sa2, by = "sa2_code") |>
    mutate(children_per_point = population / n_points) |>
    group_by(nearest_school, school_type) |>
    summarise(
      children_served = sum(children_per_point, na.rm = TRUE),
      avg_walk_time_min = mean(nearest_walk_time_min, na.rm = TRUE),
      n_points_served = n(),
      .groups = "drop"
    )
  
  # Create complete list - ONLY for schools that match their type
  # This eliminates the duplication issue
  all_school_types <- active_schools |>
    mutate(
      school_type = case_when(
        type == "primary" ~ "primary",
        type == "high" ~ "high",
        TRUE ~ NA_character_
      )
    ) |>
    filter(!is.na(school_type)) # Remove any schools with unknown types
  
  # Join with results, filling missing schools with zeros
  complete_results <- all_school_types |>
    left_join(results_with_children, by = c("school" = "nearest_school", "school_type")) |>
    mutate(
      children_served = ifelse(is.na(children_served), 0, children_served),
      avg_walk_time_min = ifelse(is.na(avg_walk_time_min), NA, avg_walk_time_min),
      n_points_served = ifelse(is.na(n_points_served), 0, n_points_served)
    ) |>
    select(nearest_school = school, school_type, children_served, avg_walk_time_min, n_points_served) |>
    arrange(school_type, desc(children_served))
  
  # Save results
  if (!dir.exists("data/closest_school")) {
    dir.create("data/closest_school", recursive = TRUE)
  }
  
  output_file <- paste0("data/closest_school/school_catchments_", year_selected, ".csv")
  write.csv(complete_results, output_file, row.names = FALSE)
  
  schools_with_children <- sum(complete_results$children_served > 0)
  schools_with_zero <- sum(complete_results$children_served == 0)
  
  cat("Results saved to:", output_file, "\n")
  cat("Schools with children:", schools_with_children, "\n")
  cat("Schools with 0 children:", schools_with_zero, "\n")
  cat("Total schools:", nrow(complete_results), "\n")
  
  return(complete_results)
}
# Get complete catchment data with zeros included
catchments_complete_2024 <- get_school_catchments(2024, erp, random_locations, 
  schools_sf, act_networks_2024)
sum(catchments_by_type_2024$children_served)
# Sense check that the weighting is working, might not be perfect but should be 
# close
sum(erp[erp$year == 2024,]$erp)


catchments_complete_2001 <- get_school_catchments(2001, erp, random_locations, 
  schools_sf, act_networks_2024)

#-------------------------------------------------------------------------------
# ---- 5) TODO Calc per suburb distance with new location? ----
#-------------------------------------------------------------------------------



#-----------------------------
# Trouble Shooting
#---------------------------------

# Random locations and primary schools to eyeball the closest location
# Generated by Claude 3.5 Sonnet
# Quick troubleshooting map for ACT primary schools and random locations
library(leaflet)
library(sf)

# Get active primary schools for 2024
primary_schools_2024 <- schools_sf |>
  filter(open <= 2024 & (is.na(close) | close >= 2024), type == "primary")

# Create the map
troubleshoot_map <- leaflet() |>
  addProviderTiles(providers$CartoDB.Positron) |>
  # Add primary schools in red
  addCircleMarkers(
    data = primary_schools_2024,
    color = "red",
    fillColor = "red",
    fillOpacity = 0.8,
    radius = 8,
    popup = ~paste0("Primary School: ", school, "<br>",
                   "Open: ", open, " - ", ifelse(is.na(close), "Current", close)),
    group = "Primary Schools"
  ) |>
  # Add random locations in blue
  addCircleMarkers(
    data = random_locations,
    color = "blue",
    fillColor = "blue",
    fillOpacity = 0.6,
    radius = 3,
    popup = ~paste0("SA2: ", sa2_name, "<br>",
                   "Point ID: ", point_id),
    group = "Random Locations"
  ) |>
  # Add layer control
  addLayersControl(
    overlayGroups = c("Primary Schools", "Random Locations"),
    options = layersControlOptions(collapsed = FALSE)
  ) |>
  setView(lng = 149.12, lat = -35.30, zoom = 10)

# Display the map
troubleshoot_map

# Quick stats for troubleshooting
cat("Primary schools in 2024:", nrow(primary_schools_2024), "\n")
cat("Random locations:", nrow(random_locations), "\n")
cat("SA2 areas with random points:", length(unique(random_locations$sa2_code)), "\n")

##################################
## Generated by Claude 3.5 Sonnet
# Fixed map showing network around Aranda school
library(leaflet)
library(sf)

# Simple approach - create individual line segments for the network
create_network_lines_sf <- function(network_data) {
  # Create line geometries for each network edge
  lines_list <- lapply(1:nrow(network_data), function(i) {
    coords <- matrix(c(network_data$from_lon[i], network_data$from_lat[i],
                      network_data$to_lon[i], network_data$to_lat[i]), 
                    ncol = 2, byrow = TRUE)
    st_linestring(coords)
  })
  
  # Convert to sf object
  st_sf(
    geometry = st_sfc(lines_list, crs = 4326)
  )
}

# Create sf lines for the network around Aranda
network_lines_sf <- create_network_lines_sf(aranda_network)

# Create the fixed troubleshooting map
aranda_network_map_fixed <- leaflet() |>
  addProviderTiles(providers$CartoDB.Positron) |>
  # Add network edges as sf lines
  addPolylines(
    data = network_lines_sf,
    color = "gray",
    weight = 1,
    opacity = 0.7,
    group = "Network Edges"
  ) |>
  # Add Aranda school in red
  addCircleMarkers(
    data = schools_sf |> filter(school == "Aranda"),
    lng = ~longitude,
    lat = ~latitude,
    color = "red",
    fillColor = "red",
    radius = 10,
    fillOpacity = 1,
    popup = ~paste("ARANDA SCHOOL"),
    group = "Aranda School"
  ) |>
  # Add other schools in orange
  addCircleMarkers(
    data = nearby_schools |> filter(school != "Aranda"),
    lng = ~longitude,
    lat = ~latitude,
    color = "orange",
    fillColor = "orange", 
    radius = 8,
    fillOpacity = 0.8,
    popup = ~paste("School:", school),
    group = "Other Schools"
  ) |>
  # Add random points in blue
  addCircleMarkers(
    data = nearby_points,
    lng = ~longitude,
    lat = ~latitude,
    color = "blue",
    fillColor = "blue",
    radius = 3,
    fillOpacity = 0.6,
    popup = ~paste("SA2:", sa2_name, "Point:", point_id),
    group = "Random Points"
  ) |>
  addLayersControl(
    overlayGroups = c("Network Edges", "Aranda School", "Other Schools", "Random Points"),
    options = layersControlOptions(collapsed = FALSE)
  ) |>
  setView(lng = aranda_lon, lat = aranda_lat, zoom = 14)

# Display the map
aranda_network_map_fixed


###############################
# Generated by Claude 3.5 Sonnet
# Fixed function for problematic schools in ACT - corrected geometry assignment
fix_problematic_schools <- function(schools_sf) {
  
  # Identify the 5 problematic schools
  problem_schools <- c("Aranda", "Taylor", "Chisholm", "Campbell", "Alternative Education Program")
  
  # Manual coordinate adjustments based on visual inspection
  school_fixes <- data.frame(
    school = c("Aranda", "Taylor", "Chisholm", "Campbell", "Alternative Education Program"),
    new_lon = c(149.078, 149.090, 149.027, 149.155, 149.130),
    new_lat = c(-35.256, -35.190, -35.430, -35.285, -35.270),
    stringsAsFactors = FALSE
  )
  
  # Create corrected schools dataset
  schools_corrected <- schools_sf
  
  for(i in 1:nrow(school_fixes)) {
    school_name <- school_fixes$school[i]
    new_coords <- c(school_fixes$new_lon[i], school_fixes$new_lat[i])
    
    # Find the school row
    school_idx <- which(schools_corrected$school == school_name)
    
    if(length(school_idx) > 0) {
      # Fix: Correct geometry assignment for sf objects
      schools_corrected$geom[school_idx] <- st_sfc(st_point(new_coords), crs = 4326)
      # Fix: Use correct variable names from school_fixes
      schools_corrected$longitude[school_idx] <- school_fixes$new_lon[i]
      schools_corrected$latitude[school_idx] <- school_fixes$new_lat[i]
      cat("Fixed", school_name, "coordinates\n")
    }
  }
  
  return(schools_corrected)
}

# Apply the fix
schools_fixed <- fix_problematic_schools(schools_sf)

# Test the fix
test_aranda_fix <- function(schools_fixed) {
  aranda_fixed <- schools_fixed |> filter(school == "Aranda")
  aranda_point <- random_locations |> filter(sa2_code == "801011001", point_id == 1)
  
  fixed_time <- dodgr_times(
    act_networks_2024$net_contracted,
    from = st_coordinates(aranda_point),
    to = st_coordinates(aranda_fixed)
  ) / 60
  
  cat("Walking time to fixed Aranda:", round(fixed_time, 1), "minutes\n")
  return(fixed_time)
}

fixed_time <- test_aranda_fix(schools_fixed)
